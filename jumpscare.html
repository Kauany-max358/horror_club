<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eu disse pra não clicar!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pirata+One&family=Sanchez:ital@0;1&display=swap');
        :root {
            --primary-color: #990000;
            --secondary-color: #e8eaed;
            --bg-color: #121212;
        }
        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--secondary-color);
            font-family: "Sanchez", serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        h1 {
            font-family: 'Pirata One', cursive;
            color: var(--primary-color);
            font-size: 3rem;
            text-shadow: 0 0 10px var(--primary-color), 0 0 20px rgba(153, 0, 0, 0.8);
            animation: flicker 4s infinite;
        }
        #game-canvas {
            border: 1px solid #555;
            background-color: #000;
            cursor: crosshair;
            width: 95%; /* Usa largura percentual para se adaptar */
            max-width: 600px; /* Mantém o tamanho máximo original em telas grandes */
            aspect-ratio: 3 / 2; /* Mantém a proporção 600/400 */
        }
        .jumpscare-video-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 1000;
        }

        /* Efeitos de TV Antiga */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23n)' opacity='0.3'/%3E%3C/svg%3E");
            background-repeat: repeat;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.05;
            animation: static-noise 0.2s steps(2, end) infinite;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 4px 100%;
            pointer-events: none;
            z-index: 1001;
            animation: scanlines 2s linear infinite;
        }

        @keyframes static-noise {
            0%, 100% { background-position: 0 0; }
            10% { background-position: -5% -10%; }
            20% { background-position: -15% 5%; }
            30% { background-position: 7% -25%; }
            40% { background-position: 20% 25%; }
            50% { background-position: -20% 10%; }
            60% { background-position: 15% 5%; }
            70% { background-position: 0 15%; }
            80% { background-position: 25% 35%; }
            90% { background-position: -10% 10%; }
        }

        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
                text-shadow: 0 0 10px var(--primary-color), 0 0 20px rgba(153, 0, 0, 0.8);
            }
            20%, 24%, 55% {
                opacity: 0.5;
                text-shadow: none;
            }
        }
        @media (max-width: 640px) {
            h1 {
                font-size: 2rem;
            }
            p {
                font-size: 0.9rem;
                padding: 0 1rem;
            }
        }
    </style>
</head>
<body>

    <div id="game-container" class="game-container">
        <h1>Siga o ponto vermelho...</h1>
        <p>Mantenha o mouse sobre o ponto e siga o caminho até o fim. Sem truques.</p>
        <canvas id="game-canvas"></canvas>
    </div>

    <div id="cursor-shadow"></div>

    <div id="jumpscare-container" class="jumpscare-video-container">
        <!-- O vídeo será inserido aqui pelo JS -->
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.querySelector('#game-container canvas');
            const ctx = canvas.getContext('2d');
            const jumpscareContainer = document.getElementById('jumpscare-container');

            // Coordenadas relativas ao tamanho original (600x400)
            const relativePath = [
                { x: 50 / 600, y: 200 / 400 }, { x: 150 / 600, y: 100 / 400 },
                { x: 250 / 600, y: 300 / 400 }, { x: 400 / 600, y: 150 / 400 },
                { x: 550 / 600, y: 250 / 400 }
            ];
            
            let path = []; // Coordenadas absolutas calculadas
            const ball = { x: 0, y: 0, radius: 0 };
            let isDragging = false;

            function setupCanvas() {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                // Recalcula as posições com base no tamanho atual do canvas
                path = relativePath.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height }));
                ball.radius = canvas.width * (15 / 600); // Raio proporcional
                ball.x = path[0].x;
                ball.y = path[0].y;

                drawGame();
            }

            function drawGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Desenha o caminho
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) { ctx.lineTo(path[i].x, path[i].y); }
                ctx.strokeStyle = '#555';
                ctx.lineWidth = canvas.width * (30 / 600); // Largura proporcional
                ctx.lineCap = 'round';
                ctx.stroke();

                // Desenha a bolinha
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = 'red';
                ctx.fill();
            }

            function getMousePos(event) {
                const rect = canvas.getBoundingClientRect();
                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            function handleDown(event) {
                const mousePos = getMousePos(event);
                const distance = Math.sqrt((mousePos.x - ball.x) ** 2 + (mousePos.y - ball.y) ** 2);
                if (distance < ball.radius) {
                    isDragging = true;
                }
            }

            function handleUp(event) {
                if (isDragging) {
                    isDragging = false;
                    ball.x = path[0].x;
                    ball.y = path[0].y;
                    drawGame();
                }
            }

            function handleMove(event) {
                if (!isDragging) return;
                event.preventDefault(); // Previne a rolagem da página em touch
                
                const mousePos = getMousePos(event);
                ball.x = mousePos.x;
                ball.y = mousePos.y;
                
                // 1. Redesenha o jogo com a nova posição da bola.
                drawGame();
                
                // 2. Agora, com o caminho desenhado, verifica se a bola saiu dele.
                if (!ctx.isPointInStroke(ball.x, ball.y)) {
                    handleUp(event); // Se saiu, reinicia o jogo.
                    return;
                }
                
                // 3. Verifica se a bola chegou ao final.
                const endPoint = path[path.length - 1];
                const distanceToEnd = Math.sqrt((ball.x - endPoint.x) ** 2 + (ball.y - endPoint.y) ** 2);
                const endRadius = canvas.width * (20 / 600); // Tolerância proporcional

                if (distanceToEnd < endRadius) {
                    isDragging = false;
                    const gameContainer = document.getElementById('game-container');
                    gameContainer.style.display = 'none';
                    jumpscareContainer.style.display = 'block';

                    const video = document.createElement('video');
                    video.src = "mídia/WhatsApp Video 2025-11-22 at 11.25.23.mp4";
                    video.autoplay = true;
                    video.playsInline = true; // Importante para iOS
                    video.style.width = '100%';
                    video.style.height = '100%';
                    video.style.objectFit = 'cover';
                    jumpscareContainer.appendChild(video);
                    video.play().catch(e => console.error("Erro ao tocar vídeo:", e));
                }
            }

            // Eventos para mouse e toque
            canvas.addEventListener('mousedown', handleDown);
            canvas.addEventListener('mouseup', handleUp);
            canvas.addEventListener('mouseleave', handleUp); // Reinicia se o mouse sair do canvas
            canvas.addEventListener('mousemove', handleMove);

            canvas.addEventListener('touchstart', handleDown);
            canvas.addEventListener('touchend', handleUp);
            canvas.addEventListener('touchmove', handleMove);

            // Ajusta o canvas quando a janela muda de tamanho
            window.addEventListener('resize', setupCanvas);

            // Efeito de sombra seguindo o cursor
            const cursorShadow = document.getElementById('cursor-shadow');
            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;
            let cursorX = window.innerWidth / 2;
            let cursorY = window.innerHeight / 2;

            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            function animateCursor() {
                const speed = 0.15; // Ajuste para mais ou menos fluidez (menor = mais lento/atrasado)
                cursorX += (mouseX - cursorX) * speed;
                cursorY += (mouseY - cursorY) * speed;
                
                cursorShadow.style.left = `${cursorX}px`;
                cursorShadow.style.top = `${cursorY}px`;
                
                requestAnimationFrame(animateCursor);
            }
            animateCursor();

            // Configuração inicial
            setupCanvas();
        });
    </script>
</body>
</html>